import type { JSONSchema7 } from 'json-schema';

import { CodeGenerator } from 'src/codegen/CodeGenerator';
import { CodeGeneratorContext, Variant } from 'src/codegen/CodeGeneratorContext';

/**
 * Generates a type that is one of two types, depending on the current variant of code we're generating (i.e.
 * internal or external types). These variants could also be thought of as unresolved/resolved types, as all
 * expressions are resolved in the internal types and unresolved in the external types (meaning external configuration
 * can include expressions, but internal configuration have the evaluated results of these expressions).
 *
 * This is useful for 'children', for example, where the external type is a list of strings (component IDs), and the
 * internal type is a list of LayoutNode objects (as generated by the hierarchy generator).
 */
export class GenerateLinked<
  External extends CodeGenerator<any>,
  Internal extends CodeGenerator<any>,
> extends CodeGenerator<External> {
  constructor(
    public readonly external: External,
    public readonly internal: Internal,
  ) {
    super();
  }

  transformToInternal(): this | CodeGenerator<any> {
    return this.internal;
  }

  _toTypeScript(): string {
    if (CodeGeneratorContext.getTypeScriptInstance().variant === Variant.External) {
      return this.external._toTypeScript();
    }

    // We cannot just call this.resolved._toTypeScript() here, because that would just fool us. All types should be
    // deeply transformed to resolved mode instead. This exception is just thrown to guard against mistakes.
    throw new Error('Cannot generate TypeScript for linked type in internal mode - call transformToResolved() first');
  }

  toJsonSchema(): JSONSchema7 {
    return this.external.toJsonSchema();
  }

  containsExpressions(): boolean {
    // This does not contain expressions itself, but it should be treated as if it does, because we need to output
    // different types depending on the output variant.
    return true;
  }
}
