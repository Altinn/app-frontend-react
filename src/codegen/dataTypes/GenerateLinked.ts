import type { JSONSchema7 } from 'json-schema';

import { Variant } from 'src/codegen/CG';
import { CodeGenerator } from 'src/codegen/CodeGenerator';

/**
 * Generates a type that is one of two types, depending on the current variant of code we're generating (i.e.
 * internal or external types). These variants could also be thought of as unresolved/resolved types, as all
 * expressions are resolved in the internal types and unresolved in the external types (meaning external configuration
 * can include expressions, but internal configuration have the evaluated results of these expressions).
 *
 * This is useful for 'children', for example, where the external type is a list of strings (component IDs), and the
 * internal type is a list of LayoutNode objects (as generated by the hierarchy generator).
 */
export class GenerateLinked<
  External extends CodeGenerator<any>,
  Internal extends CodeGenerator<any>,
> extends CodeGenerator<External> {
  constructor(
    public readonly ext: External,
    public readonly int: Internal,
  ) {
    super();
  }

  transformTo(variant: Variant): this | CodeGenerator<any> {
    return variant === Variant.External ? this.ext.transformTo(variant) : this.int.transformTo(variant);
  }

  toTypeScript(): string {
    throw new Error('You need to transform this type to either external or internal before generating TypeScript');
  }

  toJsonSchema(): JSONSchema7 {
    return this.ext.transformTo(Variant.External).toJsonSchema();
  }

  containsVariationDifferences(): boolean {
    return true;
  }
}
