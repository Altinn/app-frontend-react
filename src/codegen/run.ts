import fs from 'node:fs/promises';
import path from 'node:path';

import { CodeGeneratorContext } from 'src/codegen/CodeGeneratorContext';
import { generateCommonSchema, generateCommonTypeScript } from 'src/codegen/Common';
import { saveFile, saveTsFile } from 'src/codegen/tools';
import type { ComponentConfig } from 'src/codegen/ComponentConfig';

async function getComponentList() {
  const out: { [folder: string]: string } = {};
  const files = await fs.readdir('src/layout');
  for (const file of files) {
    const stat = await fs.stat(path.join('src/layout', file));
    if (stat.isDirectory()) {
      if (file === 'Address') {
        // Address is a special case, because we once named it 'AddressComponent', without any over the other components
        // having that suffix. We need to keep this for backwards compatibility, but our folder structure uses the name
        // without the suffix.
        out[file] = 'AddressComponent';
        continue;
      }

      out[file] = file;
    }
  }

  return out;
}

const useNewTypes = false; // PRIORITY: Remove this once we've migrated to the new types

(async () => {
  const componentList = await getComponentList();
  const sortedKeys = Object.keys(componentList).sort((a, b) => a.localeCompare(b));
  const componentIndex = [
    '// This file is generated by running `yarn gen`',
    '',
    ...sortedKeys.map(
      (key) =>
        `import { Config as ${key}Config } from 'src/layout/${key}/${useNewTypes ? 'config.generated' : 'index'}';`,
    ),
    ...sortedKeys.map(
      (key) =>
        `import type { TypeConfig as ${key}TypeConfig } from 'src/layout/${key}/${
          useNewTypes ? 'config.generated' : 'index'
        }';`,
    ),
    '',
    `export const ComponentConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}Config,`),
    `};`,
    '',
    `export type ComponentTypeConfigs = {`,
    ...sortedKeys.map((key) => `  ${componentList[key]}: ${key}TypeConfig;`),
    `};`,
  ];

  const promises: Promise<void>[] = [];
  promises.push(saveFile('src/layout/components.generated.ts', componentIndex.join('\n')));

  const commonTsPath = 'src/layout/common.generated.ts';
  promises.push(
    saveTsFile(
      commonTsPath,
      CodeGeneratorContext.run(commonTsPath, () => generateCommonTypeScript().join('\n')),
    ),
  );

  const schemaDefs = generateCommonSchema();
  const { ILayoutCompBase: componentBaseSchema, ...otherSchemaDefs } = schemaDefs;

  for (const key of sortedKeys) {
    const config: ComponentConfig = (await import(`src/layout/${key}/config`)).Config;
    const tsPath = `src/layout/${key}/config.generated.ts`;

    const content = CodeGeneratorContext.run(tsPath, () => {
      config.setType(componentList[key], key);
      return config.toTypeScript();
    });
    promises.push(saveTsFile(tsPath, content));

    otherSchemaDefs[`Comp${key}`] = config.toJsonSchema();
  }

  const schemaPath = 'schemas/json/layout/layout.schema.v2.generated.json';
  promises.push(
    saveFile(
      schemaPath,
      JSON.stringify(
        {
          $schema: 'http://json-schema.org/draft-07/schema#',
          $id: 'https://altinncdn.no/schemas/json/layout/layout.schema.v1.json',
          title: 'Altinn layout',
          description: 'Schema that describes the layout configuration for Altinn applications.',
          type: 'object',
          additionalProperties: false,
          properties: {
            $schema: { type: 'string' },
            data: {
              $ref: '#/definitions/data',
            },
          },
          definitions: {
            data: {
              title: 'The layout data',
              description: 'Contains data describing the layout configuration.',
              type: 'object',
              properties: {
                layout: {
                  $ref: '#/definitions/layout',
                },
              },
            },
            layout: {
              title: 'The layout',
              description: 'Array of components to be presented in the layout.',
              type: 'array',
              items: {
                $ref: '#/definitions/component',
              },
            },
            component: {
              ...componentBaseSchema,
              properties: {
                ...componentBaseSchema.properties,
                type: {
                  // This is a trick to make the type property required, but still override the type with a const value
                  // in each of the component schemas (not normally possible with this code generator)
                  title: 'Type',
                  description: 'The component type',
                  enum: sortedKeys.map((key) => componentList[key]),
                },
              },
              required: [...(componentBaseSchema.required || []), 'type'],
              allOf: sortedKeys.map((key) => ({
                if: { properties: { type: { const: componentList[key] } } },
                then: { $ref: `#/definitions/Comp${key}` },
              })),
            },
            ...otherSchemaDefs,
          },
        },
        null,
        2,
      ),
    ),
  );

  await Promise.all(promises);
})();
